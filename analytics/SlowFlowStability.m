function [stable,varargout] = SlowFlowStability(solution,sys,exc,xi,r,disorder)
% Determine the stability of the GSR or LSR as the stability of the
% corresponding fixed-point in the slow flow

% Auxilliary Variable
rho = (2/pi) * (1-sys.eN) / (1+sys.eN);

% Inter-sector phase angle
theta_k0 = 2*pi*exc.k/sys.N_s;

switch solution
    case 'LSR_single'
        [Q,~,~] = RecoverCondensedDOFs(sys,exc,r,xi,'single',disorder);

        % Assign Synchronized Sectors
        syn_sectors    = eye(sys.N_s,1);
    case 'LSR_opposing'
        [Q,~,~] = RecoverCondensedDOFs(sys,exc,r,xi,'opposing');

        if strcmp(disorder,'mistuned')
            error('Mistuned GSR not implemented.')
        end

        % Assign Synchronized Sectors
        syn_sectors             = eye(sys.N_s,1);
        syn_sectors(sys.N_s/2+1)  = 1;
    case 'GSR'

        if strcmp(disorder,'mistuned')
            error('Mistuned GSR not implemented.')
        end

        Q    = sys.Gamma(1)*xi;
        
        % Triangle Wave Amplitude of absorber
        qahat = (sys.Gamma(1:sys.N_s)+sqrt((1+rho^2)* abs(Q).^2 ...
            - (sys.Gamma(1:sys.N_s)*rho).^2))/(1+rho^2);
        
        Delta = acos((qahat-sys.Gamma(1:sys.N_s))./abs(Q)); 
        
        % Get Phase shift if only uniform amplitude is given
        Q = Q./((-(1-sys.epsilon_a)*exc.harmonic.r^2 + ...
            2*sys.D*exc.harmonic.r*...
            sys.r_k(exc.k+1)*1i + ...
            sys.r_k(exc.k+1)^2)*abs(Q)-8*sys.epsilon_a*...
            exc.harmonic.r^2*qahat.*exp(-1i*Delta)/pi^2);

        Q=Q.*exp(1i*theta_k0*(0:(sys.N_s-1))');
                
        % Assign Synchronized Sectors
        syn_sectors    = ones(sys.N_s,1);

    otherwise
        error('Case not defined.')
end

% Determine Phase Angle Matrix
gamma           = angle(Q);
gamma_diff      = gamma'-gamma;
cos_gamma_diff  = cos(gamma_diff);
sin_gamma_diff  = sin(gamma_diff);

% Constant Factor
alpha           = 1/(2*(1-sys.epsilon_a)*r);

% Real Amplitude
qhat        = abs(Q);



% Linear component
switch disorder
    case 'tuned'
        
        dqhatdot_dqhat     = -alpha*(sys.K.*sin_gamma_diff ...
                        + r*sys.C.*cos_gamma_diff);

        dqhatdot_dgamma    = -alpha*(sys.K.*cos_gamma_diff ...
                            -r*sys.C.*sin_gamma_diff) .* ...
                            repmat(qhat',[sys.N_s,1]);

        dgammadot_dqhat    = alpha*(sys.K.*cos_gamma_diff ...
                            -r*sys.C.*sin_gamma_diff) ./ ...
                            repmat(qhat,[1,sys.N_s]);

        dgammadot_dgamma   = -alpha*(sys.K.*sin_gamma_diff ...
                            +r*sys.C.*cos_gamma_diff) .* ...
                            (qhat' ./ qhat);
        
        % Main Diagonal
        for j = 1:sys.N_s
            
            % Boolean Neighboring sectors
            nb                  = true(sys.N_s,1);
            nb(j)               = false;

            dqhatdot_dqhat(j,j)    =   -alpha*r*sys.C(j,j);

            dqhatdot_dgamma(j,j)   =   -alpha*( ...
                cos( theta_k0*(j-1)-gamma(j) ) + ...
                sum( ...
                ( ...
                -sys.K(j,nb).*cos_gamma_diff(j,nb) + ...
                 r*sys.C(j,nb).*sin_gamma_diff(j,nb) ...
                 ).*(qhat(nb)') ...
                 ) ...
                 );
            
            dgammadot_dqhat(j,j)   =   alpha*( ...
                cos( theta_k0*(j-1)-gamma(j) ) - ...
                sum(...
                ( ...
                sys.K(j,nb).*cos_gamma_diff(j,nb) - ...
                 r*sys.C(j,nb).*sin_gamma_diff(j,nb) ...
                ).*(qhat(nb)') ...
                ) ...
                )/qhat(j)^2;
            
            dgammadot_dgamma(j,j)  =   alpha*( ...
                -sin( theta_k0*(j-1)-gamma(j) ) + ...
                sum(...
                ( ...
                sys.K(j,nb).*sin_gamma_diff(j,nb) + ...
                 r*sys.C(j,nb).*cos_gamma_diff(j,nb) ...
                ).*(qhat(nb)') ...
                ) ...
                )/qhat(j);
            
            % Check if Sector is synchronized
            if syn_sectors(j)
                
                % Build Helper Expressions
                qahat           = (sys.Gamma(j)+sqrt((1+rho^2)*qhat(j)^2 ...
                    - (sys.Gamma(j)*rho)^2))/(1+rho^2);     
                
                daqhat_dqhat    = qhat(j)/sqrt((1+rho^2)*qhat(j)^2 ...
                    - (sys.Gamma(j)*rho)^2);              
                
                % Add nonlinear derivative terms to main diagonal
                dqhatdot_dqhat(j,j)    =   dqhatdot_dqhat(j,j) + ...
                    alpha*( ...
                    8*sys.epsilon_a*r^2*rho*qahat^2/(pi^2*qhat(j)^2) - ...
                    16*sys.epsilon_a*r^2*rho*qahat/(pi^2*qhat(j))* ...
                    daqhat_dqhat ...
                    );

                dgammadot_dqhat(j,j)   = dgammadot_dqhat(j,j) + ...
                    alpha*( ...
                    16*sys.epsilon_a*r^2*qahat* ...
                    (qahat-sys.Gamma(j))/(pi^2*qhat(j)^3) - ...
                    8*sys.epsilon_a*r^2/(pi^2*qhat(j)^2)* ...
                    (2*qahat-sys.Gamma(j))*daqhat_dqhat ...
                    );
            end

        end

    case 'mistuned'
        dqhatdot_dqhat     = -alpha*(sys.K_mt.*sin_gamma_diff ...
                        + r*sys.C_mt.*cos_gamma_diff);

        dqhatdot_dgamma    = -alpha*(sys.K_mt.*cos_gamma_diff ...
                            -r*sys.C_mt.*sin_gamma_diff) .* ...
                            repmat(qhat',[sys.N_s,1]);

        dgammadot_dqhat    = alpha*(sys.K_mt.*cos_gamma_diff ...
                            -r*sys.C_mt.*sin_gamma_diff) ./ ...
                            repmat(qhat,[1,sys.N_s]);

        dgammadot_dgamma   = -alpha*(sys.K_mt.*sin_gamma_diff ...
                            +r*sys.C_mt.*cos_gamma_diff) .* ...
                            (qhat' ./ qhat);
        
        % Main Diagonal
        for j = 1:sys.N_s
            
            % Boolean Neighboring sectors
            nb                  = true(sys.N_s,1);
            nb(j)               = false;

            dqhatdot_dqhat(j,j)    =   -alpha*r*sys.C_mt(j,j);

            dqhatdot_dgamma(j,j)   =   -alpha*( ...
                cos( theta_k0*(j-1)-gamma(j) ) + ...
                sum( ...
                ( ...
                -sys.K_mt(j,nb).*cos_gamma_diff(j,nb) + ...
                 r*sys.C_mt(j,nb).*sin_gamma_diff(j,nb) ...
                 ).*(qhat(nb)') ...
                 ) ...
                 );
            
            dgammadot_dqhat(j,j)   =   alpha*( ...
                cos( theta_k0*(j-1)-gamma(j) ) - ...
                sum(...
                ( ...
                sys.K_mt(j,nb).*cos_gamma_diff(j,nb) - ...
                 r*sys.C_mt(j,nb).*sin_gamma_diff(j,nb) ...
                ).*(qhat(nb)') ...
                ) ...
                )/qhat(j)^2;
            
            dgammadot_dgamma(j,j)  =   alpha*( ...
                -sin( theta_k0*(j-1)-gamma(j) ) + ...
                sum(...
                ( ...
                sys.K_mt(j,nb).*sin_gamma_diff(j,nb) + ...
                 r*sys.C_mt(j,nb).*cos_gamma_diff(j,nb) ...
                ).*(qhat(nb)') ...
                ) ...
                )/qhat(j);
            
            % Check if Sector is synchronized
            if syn_sectors(j)
                
                % Build Helper Expressions
                qahat           = (sys.Gamma_mt(j)+sqrt((1+rho^2)*qhat(j)^2 ...
                    - (sys.Gamma_mt(j)*rho)^2))/(1+rho^2);     
                
                daqhat_dqhat    = qhat(j)/sqrt((1+rho^2)*qhat(j)^2 ...
                    - (sys.Gamma_mt(j)*rho)^2);             
                
                % Add nonlinear derivative terms to main diagonal
                dqhatdot_dqhat(j,j)    =   dqhatdot_dqhat(j,j) + ...
                    alpha*( ...
                    8*sys.epsilon_a*r^2*rho*qahat^2/(pi^2*qhat(j)^2) - ...
                    16*sys.epsilon_a*r^2*rho*qahat/(pi^2*qhat(j))* ...
                    daqhat_dqhat ...
                    );


                dgammadot_dqhat(j,j)   = dgammadot_dqhat(j,j) + ...
                    alpha*( ...
                    16*sys.epsilon_a*r^2*qahat* ...
                    (qahat-sys.Gamma_mt(j))/(pi^2*qhat(j)^3) - ...
                    8*sys.epsilon_a*r^2/(pi^2*qhat(j)^2)* ...
                    (2*qahat-sys.Gamma_mt(j))*daqhat_dqhat ...
                    );
            end

        end
    otherwise
        error('Case not defined.')
end

% Assemble Jacobian
J       =   [dqhatdot_dqhat    ,   dqhatdot_dgamma;
             dgammadot_dqhat   ,   dgammadot_dgamma];

% Compute Eigenvalues
lambda  =   eig(J);

% Check if real part of Eigenvalues in left half of complex plane
stable  =   all(real(lambda)<=0);

if nargout==2
    varargout{1}    = qhat;
elseif nargout==3
    varargout{1}    = qhat;
    varargout{2}    = lambda;
end

end


